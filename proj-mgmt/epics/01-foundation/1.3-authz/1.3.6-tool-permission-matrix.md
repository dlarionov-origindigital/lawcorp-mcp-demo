# 1.3.6: Tool permission matrix and enforcement

**Status:** BACKLOG
**Type:** Story
**Feature:** [1.3: Custom Authorization Layer](./1.3-authorization.md)
**Tags:** `+auth` `+rbac` `+mcp-tools`

---

As a system administrator,
I want each user role to see and invoke only the MCP tools they are authorized to use,
So that the tool surface is scoped per identity and the OBO token correctly gates access from the first protocol handshake.

## Context

The PRD Section 4.2 permissions matrix defines domain-level access per role (Cases, Documents, Billing, etc.). This story translates that matrix to **tool-level granularity** — producing a static `ToolPermissionMatrix` that maps each `FirmRole` to the set of tool names it may access.

Enforcement is applied at two layers:

1. **`tools/list`** — the server filters the registered tool roster before returning it; each caller sees only their permitted tools
2. **`tools/call`** — the tool handler checks the permission policy as a fast-fail guard before executing any business logic

This is the first place the OBO identity chain produces a user-visible effect: two different tokens from two different roles will result in two different `tools/list` responses. Story 8.2.6 provides the web UI that demonstrates this.

## Role → Tool Mapping

*Row-level scoping (e.g., Associate sees only assigned cases) is enforced by the EF Core query filters in 1.3.2, not by this matrix. This matrix governs tool visibility and invocability only.*

| Tool | Partner | Associate | Of Counsel | Paralegal | Legal Asst | Intern |
|---|:---:|:---:|:---:|:---:|:---:|:---:|
| `cases_search` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `cases_get` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `cases_update_status` | ✓ | ✓ | — | — | — | — |
| `cases_assign_attorney` | ✓ | — | — | — | — | — |
| `cases_get_timeline` | ✓ | ✓ | ✓ | ✓ | ✓ | — |
| `cases_add_note` | ✓ | ✓ | ✓ | ✓ | — | — |
| `documents_search` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `documents_get` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `documents_draft` | ✓ | ✓ | — | ✓ | — | — |
| `documents_update_status` | ✓ | ✓ | — | — | — | — |
| `documents_list_by_case` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `clients_search` | ✓ | ✓ | ✓ | ✓ | — | — |
| `clients_get` | ✓ | ✓ | ✓ | ✓ | — | — |
| `clients_conflict_check` | ✓ | ✓ | — | ✓ | — | — |
| `contacts_search` | ✓ | ✓ | ✓ | ✓ | ✓ | — |
| `contacts_get` | ✓ | ✓ | ✓ | ✓ | ✓ | — |
| `time_entries_log` | ✓ | ✓ | ✓ | — | — | — |
| `time_entries_search` | ✓ | ✓ | ✓ | — | — | — |
| `billing_get_summary` | ✓ | — | — | — | — | — |
| `invoices_search` | ✓ | — | — | — | — | — |
| `invoices_get` | ✓ | — | — | — | — | — |
| `calendar_get_hearings` | ✓ | ✓ | ✓ | ✓ | ✓ | — |
| `calendar_get_deadlines` | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ |
| `calendar_add_event` | ✓ | ✓ | — | — | — | — |
| `calendar_get_conflicts` | ✓ | ✓ | ✓ | — | — | — |
| `research_search_precedents` | ✓ | ✓ | ✓ | ✓ | — | — |
| `research_get_statute` | ✓ | ✓ | ✓ | ✓ | — | — |
| `research_get_memo` | ✓ | ✓ | ✓ | ✓ | — | ✓ |
| `research_create_memo` | ✓ | ✓ | ✓ | ✓ | — | ✓ |
| `research_search_memos` | ✓ | ✓ | ✓ | ✓ | — | ✓ |
| `intake_create_request` | ✓ | ✓ | — | ✓ | ✓ | — |
| `intake_get_request` | ✓ | ✓ | — | ✓ | ✓ | — |
| `intake_run_conflict_check` | ✓ | ✓ | — | ✓ | — | — |
| `intake_approve` | ✓ | — | — | — | — | — |
| `intake_generate_engagement_letter` | ✓ | ✓ | — | — | — | — |

## Implementation Steps

- [ ] Define `IToolPermissionPolicy` interface in `LawCorp.Mcp.Core/Auth/`:
  ```csharp
  public interface IToolPermissionPolicy
  {
      bool IsAllowed(string toolName, IFirmIdentityContext identity);
      IReadOnlyList<string> GetPermittedTools(IFirmIdentityContext identity);
  }
  ```
- [ ] Implement `ToolPermissionMatrix : IToolPermissionPolicy` in `LawCorp.Mcp.Server/Auth/` — a static `Dictionary<FirmRole, IReadOnlySet<string>>` lookup built from the table above
- [ ] Register `IToolPermissionPolicy` as a **singleton** in `AuthServiceCollectionExtensions` (the matrix is stateless)
- [ ] Override the MCP `tools/list` handler to inject `IToolPermissionPolicy` and filter the registered tool roster against the resolved `IFirmIdentityContext` before returning the list
- [ ] Add a guard to the `tools/call` invocation pipeline that calls `policy.IsAllowed()` before handing off to the tool handler; return a structured `McpError` with code `-32001` (Unauthorized) on failure — do not throw an unhandled exception
- [ ] Add unit tests asserting:
  - Each role's permitted set matches the table above exactly
  - Calling a denied tool returns the correct MCP error code and message
  - `GetPermittedTools()` returns an empty list for an unknown role (fail-safe)

## Acceptance Criteria

- [ ] Harvey Specter (Partner) receives all 35 tools in a `tools/list` response
- [ ] An Intern persona receives exactly the tools marked ✓ for Intern in the table above
- [ ] Calling a denied tool returns a structured MCP error (`-32001`), not an unhandled exception
- [ ] `ToolPermissionMatrix` has unit test coverage for every role's permitted set
- [ ] `IToolPermissionPolicy` resolves from DI without an active `HttpContext` (required for the test harness in Epic 7)

## Dependencies

- 1.3.5 (`IFirmIdentityContext`) — identity must be resolved before the matrix can be evaluated (this dependency is already IN PROGRESS)
- 1.3.1 (authorization handler) — builds on the same RBAC model; the two implementations should reference the same `FirmRole` enum

## Notes

Row-level and field-level enforcement (1.3.2, 1.3.3) are complementary — this story handles *which tools are visible and invocable*, not *what data those tools return*. Both layers are needed for the full RBAC picture.

The tool-level matrix is intentionally coarse-grained (role → allowed tools) rather than fine-grained (role + entity + action). Row-level and field-level stories handle the finer-grained constraints within each tool's execution.

Story 8.2.6 provides the first web UI that makes this filtering observable to a human.
