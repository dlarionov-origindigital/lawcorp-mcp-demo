# 1.4.1: Create `LawCorp.Mcp.ExternalApi` project with JWT Bearer auth

**Status:** DONE
**Type:** Story
**Feature:** [1.4: External Downstream API Service](./1.4-external-api.md)
**Tags:** `+auth`, `+architecture`

---

As a developer setting up the reference architecture,
I want an independent downstream API project in the solution,
So that the MCP server can demonstrate multi-hop OBO to a custom API we control.

- [x] Create `LawCorp.Mcp.ExternalApi` ASP.NET Core Web API project in the solution
- [x] Configure JWT Bearer authentication via `Microsoft.Identity.Web` — validates OBO tokens from the MCP server
- [x] Add project reference to `LawCorp.Mcp.Core` (for `FirmRole` enum — external API has its own `DmsDbContext`)
- [x] Configure Kestrel to listen on port 5002 via `launchSettings.json`
- [x] Add `appsettings.json` with empty placeholders (tracked) and `appsettings.Development.json.example` (tracked) pattern
- [x] Add health check endpoint (`/health`) via `HealthController`

## Acceptance Criteria

- [x] Project builds and runs independently (`dotnet run --project src/LawCorp.Mcp.ExternalApi`)
- [x] JWT Bearer middleware validates tokens with the external API's `AzureAd:ClientId` and `Audience`
- [x] Invalid/expired tokens return 401 (all endpoints marked `[Authorize]`)
- [x] Project follows the same `appsettings.json` / `.Development.json.example` / `.Development.json` (gitignored) pattern as the MCP server

## Notes

The external API is a standard ASP.NET Core Web API — not an MCP server. It uses controllers, not MCP tool handlers.
The external API has its own database (`LawCorpDms`) with its own `DmsDbContext` and domain models (`DmsWorkspace`, `DmsDocument`, `DmsAccessRule`), simulating a real-world DMS like iManage or NetDocuments. It references `LawCorp.Mcp.Core` only for the shared `FirmRole` enum.
