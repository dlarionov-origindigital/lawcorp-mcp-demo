# 1.5.2: Create `LawCorp.Mcp.Server.Handlers` project

**Status:** DONE
**Type:** Story
**Feature:** [1.5: CQRS Dispatch Pattern for MCP Tools](./1.5-cqrs-dispatch.md)
**Tags:** `+architecture`, `+cqrs`

---

As a developer implementing data access for MCP tools,
I want a dedicated handlers project separate from the MCP server,
So that data access logic is isolated and testable without pulling in the full MCP server dependency chain.

- [x] Create `LawCorp.Mcp.Server.Handlers` class library project (net9.0)
- [x] Add project references: `LawCorp.Mcp.Core` (contracts), `LawCorp.Mcp.Data` (DbContext)
- [x] Implement `SearchCasesHandler : IRequestHandler<SearchCasesQuery, SearchCasesResult>` — queries local database
- [x] Implement `GetCaseByIdHandler : IRequestHandler<GetCaseByIdQuery, GetCaseResult>` — queries local database
- [x] Implement `UpdateCaseStatusHandler : IRequestHandler<UpdateCaseStatusCommand, CommandResult>` — updates local database
- [x] Inject `IUserContext` in handlers for identity-scoped queries
- [x] Register handler assembly in MediatR DI configuration (`.RegisterServicesFromAssemblyContaining<SearchCasesHandler>()`)
- [x] Add the project to the solution file

## Acceptance Criteria

- [x] Project builds cleanly and is referenced by `LawCorp.Mcp.Server`
- [x] 3 local-DB handlers + 3 external-API handlers implemented and registered
- [x] Handlers inject `DbContext` and `IUserContext` — not the tool classes
- [x] Handlers are unit-testable (inject fakes for DbContext and identity)
- [x] MediatR resolves handlers from the handlers assembly at runtime

## Notes

This project sits between Core (contracts) and Server (MCP tools). Tools dispatch to MediatR; MediatR resolves handlers from this project. The handlers know about data sources; the tools do not.

Dependency graph: `Server` → `Server.Handlers` → `Core`, `Data`
