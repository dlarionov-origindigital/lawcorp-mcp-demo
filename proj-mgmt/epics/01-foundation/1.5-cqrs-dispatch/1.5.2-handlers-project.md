# 1.5.2: Create `LawCorp.Mcp.Server.Handlers` project

**Status:** BACKLOG
**Type:** Story
**Feature:** [1.5: CQRS Dispatch Pattern for MCP Tools](./1.5-cqrs-dispatch.md)
**Tags:** `+architecture`, `+cqrs`

---

As a developer implementing data access for MCP tools,
I want a dedicated handlers project separate from the MCP server,
So that data access logic is isolated and testable without pulling in the full MCP server dependency chain.

- [ ] Create `LawCorp.Mcp.Server.Handlers` class library project
- [ ] Add project references: `LawCorp.Mcp.Core` (contracts), `LawCorp.Mcp.Data` (DbContext)
- [ ] Implement `SearchCasesHandler : IRequestHandler<SearchCasesQuery, SearchCasesResult>` — queries local database
- [ ] Implement `GetCaseByIdHandler : IRequestHandler<GetCaseByIdQuery, CaseResult>` — queries local database
- [ ] Inject `IFirmIdentityContext` in handlers for identity-scoped queries
- [ ] Register handler assembly in MediatR DI configuration (`.RegisterServicesFromAssembly(...)`)
- [ ] Add the project to the solution file

## Acceptance Criteria

- [ ] Project builds cleanly and is referenced by `LawCorp.Mcp.Server`
- [ ] At least 2 handlers are implemented and registered
- [ ] Handlers inject `DbContext` and `IFirmIdentityContext` — not the tool classes
- [ ] Handlers are unit-testable (inject fakes for DbContext and identity)
- [ ] MediatR resolves handlers from the handlers assembly at runtime

## Notes

This project sits between Core (contracts) and Server (MCP tools). Tools dispatch to MediatR; MediatR resolves handlers from this project. The handlers know about data sources; the tools do not.

Dependency graph: `Server` → `Server.Handlers` → `Core`, `Data`
